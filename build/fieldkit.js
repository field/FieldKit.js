;(function(e,t,n){function r(n,i){if(!t[n]){if(!e[n]){var s=typeof require=="function"&&require;if(!i&&s)return s(n,!0);throw new Error("Cannot find module '"+n+"'")}var o=t[n]={exports:{}};e[n][0](function(t){var i=e[n][1][t];return r(i?i:t)},o,o.exports)}return t[n].exports}for(var i=0;i<n.length;i++)r(n[i]);return r})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
      _____  __  _____  __     ____
     / ___/ / / /____/ / /    /    \   FieldKit
    / ___/ /_/ /____/ / /__  /  /  /   (c) 2013, FIELD. All rights reserved.
   /_/        /____/ /____/ /_____/    http://www.field.io

   Created by Marcus Wendt on 07/03/2013
*/


(function() {
  var extend, fk, util;

  util = require('./util');

  extend = function() {
    var pkg;

    switch (arguments.length) {
      case 1:
        return util.extend(fk, arguments[0]);
      case 2:
        pkg = arguments[0];
        if (fk[pkg] == null) {
          fk[pkg] = {};
        }
        return util.extend(fk[pkg], arguments[1]);
    }
  };

  fk = {};

  extend(require('./color'));

  extend(require('./time'));

  extend('math', require('./math/math'));

  extend('math', require('./math/random'));

  extend('math', require('./math/noise'));

  extend('math', require('./math/vector'));

  extend('math', require('./math/rect'));

  extend('util', util);

  extend('physics', require('./physics/physics'));

  extend('physics', require('./physics/particle'));

  extend('physics', require('./physics/behaviours'));

  extend('physics', require('./physics/constraints'));

  extend('client', require('./client/sketch'));

  module.exports = fk;

  if (typeof window !== "undefined" && window !== null) {
    window.fk = fk;
  }

}).call(this);

},{"./util":2,"./color":3,"./time":4,"./math/math":5,"./math/random":6,"./math/noise":7,"./math/vector":8,"./math/rect":9,"./physics/physics":10,"./physics/particle":11,"./physics/behaviours":12,"./physics/constraints":13,"./client/sketch":14}],15:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],2:[function(require,module,exports){
(function(Buffer){// Generated by CoffeeScript 1.6.2
(function() {
  var EXObject, Mixin, clone, extend, removeElement, shuffle, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require("util");

  /*
    JavaScript Language Utilities
    ------------------------------------------------------------------------------------------
  */


  extend = function(obj, source) {
    var i, il, keys, prop, safeHasOwnProperty;

    if (Object.keys) {
      keys = Object.keys(source);
      i = 0;
      il = keys.length;
      while (i < il) {
        prop = keys[i];
        Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));
        i++;
      }
    } else {
      safeHasOwnProperty = {}.hasOwnProperty;
      for (prop in source) {
        if (safeHasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  /*
  
    Swappable Mixins in CoffeeScript
  
  
    Many thanks to Hashmal, who wrote this to start.
    https://gist.github.com/803816/aceed8fc57188c3a19ce2eccdb25acb64f2be94e
  
    Usage
    -----
  
    class Derp extends Mixin
      setup: ->
        @googly = "eyes"
  
    derp: ->
      alert "Herp derp! What's with your #{ @googly }?"
  
    class Herp
      constructor: ->
        Derp::augment this
  
    herp = new Herp
    herp.derp()
  
    Mixin
    -----
  
    Classes inheriting `Mixin` will become removable mixins, enabling you to
    swap them around.
  
    Limitations
    -----------
  
    * When a class is augmented, all instances of that class are augmented too,
      and when a mixin is ejected from a class, all instances lose that mixin too.
    * You can't eject a mixin from an object if that mixin was added to the object's class. Eject the mixin from the class instead.
  */


  Mixin = (function() {
    function Mixin() {}

    Mixin.prototype.augment = function(t) {
      var m, n;

      for (n in this) {
        m = this[n];
        if (!(n === 'augment' || (this[n].prototype == null))) {
          t[n] = m;
        }
      }
      return t.setup();
    };

    Mixin.prototype.eject = function(mixin) {
      var m, n, o, p, _results;

      _results = [];
      for (n in this) {
        m = this[n];
        _results.push(__indexOf.call((function() {
          var _ref, _results1;

          _ref = mixin.prototype;
          _results1 = [];
          for (o in _ref) {
            p = _ref[o];
            _results1.push(p);
          }
          return _results1;
        })(), m) >= 0 ? delete this[n] : void 0);
      }
      return _results;
    };

    Mixin.prototype.setup = function() {};

    return Mixin;

  })();

  /*
  
    Clones (copies) an Object using deep copying.
  
  
    This function supports circular references by default, but if you are certain
    there are no circular references in your object, you can save some CPU time
    by calling clone(obj, false).
  
    Caution: if `circular` is false and `parent` contains circular references,
    your program may enter an infinite loop and crash.
  
    @param `parent` - the object to be cloned
    @param `circular` - set to true if the object to be cloned may contain
    circular references. (optional - true by default)
  */


  clone = function(parent, circular) {
    var c, child, circularParent, circularReplace, circularResolved, cloned, i, useBuffer, _clone;

    if (typeof circular === "undefined") {
      circular = true;
    }
    useBuffer = typeof Buffer !== "undefined";
    i = void 0;
    if (circular) {
      _clone = function(parent, context, child, cIndex) {
        i = void 0;
        if (typeof parent === "object") {
          if (parent == null) {
            return parent;
          }
          for (i in circularParent) {
            if (circularParent[i] === parent) {
              circularReplace.push({
                resolveTo: i,
                child: child,
                i: cIndex
              });
              return null;
            }
          }
          circularParent[context] = parent;
          if (util.isArray(parent)) {
            child = [];
            for (i in parent) {
              child[i] = _clone(parent[i], context + "[" + i + "]", child, i);
            }
          } else if (util.isDate(parent)) {
            child = new Date(parent.getTime());
          } else if (util.isRegExp(parent)) {
            child = new RegExp(parent.source);
          } else if (useBuffer && Buffer.isBuffer(parent)) {
            child = new Buffer(parent.length);
            parent.copy(child);
          } else {
            child = {};
            child.__proto__ = parent.__proto__;
            for (i in parent) {
              child[i] = _clone(parent[i], context + "[" + i + "]", child, i);
            }
          }
          circularResolved[context] = child;
        } else {
          child = parent;
        }
        return child;
      };
      circularParent = {};
      circularResolved = {};
      circularReplace = [];
      cloned = _clone(parent, "*");
      for (i in circularReplace) {
        c = circularReplace[i];
        if (c && c.child && c.i in c.child) {
          c.child[c.i] = circularResolved[c.resolveTo];
        }
      }
      return cloned;
    } else {
      child = void 0;
      if (typeof parent === "object") {
        if (parent == null) {
          return parent;
        }
        if (parent.constructor.name === "Array") {
          child = [];
          for (i in parent) {
            child[i] = clone(parent[i], circular);
          }
        } else if (util.isDate(parent)) {
          child = new Date(parent.getTime());
        } else if (!util.isRegExp(parent)) {
          child = {};
          child.__proto__ = parent.__proto__;
          for (i in parent) {
            child[i] = clone(parent[i], circular);
          }
        }
      } else {
        child = parent;
      }
      return child;
    }
  };

  clone.clonePrototype = function(parent) {
    var ctor;

    if (parent === null) {
      return null;
    }
    ctor = function() {};
    ctor.prototype = parent;
    return new ctor();
  };

  /*
  
  JavaScript getter and setter support for CoffeeScript classes
  Ref: https://github.com/jashkenas/coffee-script/issues/1039
  
  Note:
  Classes using this wont work under IE6 + IE7
  
  Usage:
  class Vector3D extends EXObject
    constructor: (@x, @y, @z) ->
  
    @get 'x', -> @[0]
    @get 'y', -> @[1]
    @get 'z', -> @[2]
  
    @set 'x', (x) -> @[0] = x
    @set 'y', (y) -> @[1] = y
    @set 'z', (z) -> @[2] = z
  */


  EXObject = (function() {
    function EXObject() {}

    EXObject.get = function(propertyName, func) {
      return Object.defineProperty(this.prototype, propertyName, {
        configurable: true,
        enumerable: true,
        get: func
      });
    };

    EXObject.set = function(propertyName, func) {
      return Object.defineProperty(this.prototype, propertyName, {
        configurable: true,
        enumerable: true,
        set: func
      });
    };

    return EXObject;

  })();

  /*
    Array Utilities
    ------------------------------------------------------------------------------------------
  */


  removeElement = function(element, list) {
    var index;

    index = list.indexOf(element);
    if (index !== -1) {
      list.splice(index, 1);
    }
    return list;
  };

  shuffle = function(object, rng) {
    var i, j, x;

    if (rng == null) {
      rng = Math;
    }
    i = object.length;
    while (i) {
      j = parseInt(rng.random() * i);
      x = object[--i];
      object[i] = object[j];
      object[j] = x;
    }
    return object;
  };

  module.exports = {
    extend: extend,
    clone: clone,
    EXObject: EXObject,
    Mixin: Mixin,
    removeElement: removeElement,
    shuffle: shuffle
  };

}).call(this);

})(require("__browserify_buffer").Buffer)
},{"util":16,"__browserify_buffer":15}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
*/


(function() {
  var Color;

  Color = (function() {
    Color.prototype.r = 1;

    Color.prototype.g = 1;

    Color.prototype.b = 1;

    Color.prototype.a = 1;

    function Color(r, g, b, a) {
      this.r = r != null ? r : 1;
      this.g = g != null ? g : 1;
      this.b = b != null ? b : 1;
      this.a = a != null ? a : 1;
    }

    Color.prototype.set = function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      this.a = color.a;
      return this;
    };

    Color.prototype.set3 = function(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    };

    Color.prototype.randomize = function() {
      this.r = Math.random();
      this.g = Math.random();
      this.b = Math.random();
      return this;
    };

    Color.prototype.clone = function() {
      return new Color(this.r, this.g, this.b, this.a);
    };

    Color.prototype.equals = function(other) {
      if (other == null) {
        return false;
      }
      return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
    };

    Color.prototype.toCSS = function() {
      var b, g, r;

      r = Math.floor(255 * this.r);
      g = Math.floor(255 * this.g);
      b = Math.floor(255 * this.b);
      return "rgba(" + r + "," + g + "," + b + "," + this.a + ")";
    };

    Color.prototype.toString = function() {
      return "fk.Color(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
    };

    return Color;

  })();

  module.exports = {
    Color: Color
  };

}).call(this);

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*
  Base class for all types of Noise generators
*/


(function() {
  var FlowNoise, Noise, SimplexNoise,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Noise = (function() {
    function Noise() {}

    Noise.prototype.noise = function(x, y) {
      return 0;
    };

    Noise.prototype.noise2 = function(x, y) {
      return 0;
    };

    Noise.prototype.noise3 = function(x, y, z) {
      return 0;
    };

    Noise.prototype.noise4 = function(x, y, z, w) {
      return 0;
    };

    return Noise;

  })();

  /*
    Ported from Stefan Gustavson's java implementation
    http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
    Read Stefan's excellent paper for details on how this code works.
  
    Sean McCullough banksean@gmail.com
  
    Added 4D noise
    Joshua Koo zz85nus@gmail.com
  */


  SimplexNoise = (function(_super) {
    var dot;

    __extends(SimplexNoise, _super);

    function SimplexNoise(rng) {
      var i, _i, _j;

      if (rng == null) {
        rng = Math;
      }
      this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
      this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
      this.p = [];
      i = 0;
      for (i = _i = 0; _i <= 256; i = ++_i) {
        this.p[i] = Math.floor(rng.random() * 256);
      }
      this.perm = [];
      for (i = _j = 0; _j <= 512; i = ++_j) {
        this.perm[i] = this.p[i & 255];
      }
      this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
    }

    dot = function(g, x, y) {
      return g[0] * x + g[1] * y;
    };

    SimplexNoise.prototype.noise2 = function(xin, yin) {
      var F2, G2, X0, Y0, gi0, gi1, gi2, i, i1, ii, j, j1, jj, n0, n1, n2, s, t, t0, t1, t2, x0, x1, x2, y0, y1, y2;

      n0 = 0;
      n1 = 0;
      n2 = 0;
      F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
      s = (xin + yin) * F2;
      i = Math.floor(xin + s);
      j = Math.floor(yin + s);
      G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
      t = (i + j) * G2;
      X0 = i - t;
      Y0 = j - t;
      x0 = xin - X0;
      y0 = yin - Y0;
      i1 = 0;
      j1 = 0;
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } else {
        i1 = 0;
        j1 = 1;
      }
      x1 = x0 - i1 + G2;
      y1 = y0 - j1 + G2;
      x2 = x0 - 1.0 + 2.0 * G2;
      y2 = y0 - 1.0 + 2.0 * G2;
      ii = i & 255;
      jj = j & 255;
      gi0 = this.perm[ii + this.perm[jj]] % 12;
      gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12;
      gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12;
      t0 = 0.5 - x0 * x0 - y0 * y0;
      if (!(t0 < 0)) {
        t0 *= t0;
        n0 = t0 * t0 * dot(this.grad3[gi0], x0, y0);
      }
      t1 = 0.5 - x1 * x1 - y1 * y1;
      if (!(t1 < 0)) {
        t1 *= t1;
        n1 = t1 * t1 * dot(this.grad3[gi1], x1, y1);
      }
      t2 = 0.5 - x2 * x2 - y2 * y2;
      if (!(t2 < 0)) {
        t2 *= t2;
        n2 = t2 * t2 * dot(this.grad3[gi2], x2, y2);
      }
      return 70.0 * (n0 + n1 + n2);
    };

    SimplexNoise.prototype.noise3 = function(xin, yin, zin) {
      var F3, G3, X0, Y0, Z0, gi0, gi1, gi2, gi3, i, i1, i2, ii, j, j1, j2, jj, k, k1, k2, kk, n0, n1, n2, n3, s, t, t0, t1, t2, t3, x0, x1, x2, x3, y0, y1, y2, y3, z0, z1, z2, z3;

      n0 = 0;
      n1 = 0;
      n2 = 0;
      n3 = 0;
      F3 = 1.0 / 3.0;
      s = (xin + yin + zin) * F3;
      i = Math.floor(xin + s);
      j = Math.floor(yin + s);
      k = Math.floor(zin + s);
      G3 = 1.0 / 6.0;
      t = (i + j + k) * G3;
      X0 = i - t;
      Y0 = j - t;
      Z0 = k - t;
      x0 = xin - X0;
      y0 = yin - Y0;
      z0 = zin - Z0;
      i1 = 0;
      j1 = 0;
      k1 = 0;
      i2 = 0;
      j2 = 0;
      k2 = 0;
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        }
      } else {
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        }
      }
      x1 = x0 - i1 + G3;
      y1 = y0 - j1 + G3;
      z1 = z0 - k1 + G3;
      x2 = x0 - i2 + 2.0 * G3;
      y2 = y0 - j2 + 2.0 * G3;
      z2 = z0 - k2 + 2.0 * G3;
      x3 = x0 - 1.0 + 3.0 * G3;
      y3 = y0 - 1.0 + 3.0 * G3;
      z3 = z0 - 1.0 + 3.0 * G3;
      ii = i & 255;
      jj = j & 255;
      kk = k & 255;
      gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
      gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
      gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
      gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;
      t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (!(t0 < 0)) {
        t0 *= t0;
        n0 = t0 * t0 * dot(this.grad3[gi0], x0, y0, z0);
      }
      t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (!(t1 < 0)) {
        t1 *= t1;
        n1 = t1 * t1 * dot(this.grad3[gi1], x1, y1, z1);
      }
      t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (!(t2 < 0)) {
        t2 *= t2;
        n2 = t2 * t2 * dot(this.grad3[gi2], x2, y2, z2);
      }
      t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (!(t3 < 0)) {
        t3 *= t3;
        n3 = t3 * t3 * dot(this.grad3[gi3], x3, y3, z3);
      }
      return 32.0 * (n0 + n1 + n2 + n3);
    };

    SimplexNoise.prototype.noise4 = function(x, y, z, w) {
      var F4, G4, W0, X0, Y0, Z0, c, c1, c2, c3, c4, c5, c6, gi0, gi1, gi2, gi3, gi4, grad4, i, i1, i2, i3, ii, j, j1, j2, j3, jj, k, k1, k2, k3, kk, l, l1, l2, l3, ll, n0, n1, n2, n3, n4, perm, s, simplex, t, t0, t1, t2, t3, t4, w0, w1, w2, w3, w4, x0, x1, x2, x3, x4, y0, y1, y2, y3, y4, z0, z1, z2, z3, z4;

      grad4 = this.grad4;
      simplex = this.simplex;
      perm = this.perm;
      F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
      G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
      n0 = 0;
      n1 = 0;
      n2 = 0;
      n3 = 0;
      n4 = 0;
      s = (x + y + z + w) * F4;
      i = Math.floor(x + s);
      j = Math.floor(y + s);
      k = Math.floor(z + s);
      l = Math.floor(w + s);
      t = (i + j + k + l) * G4;
      X0 = i - t;
      Y0 = j - t;
      Z0 = k - t;
      W0 = l - t;
      x0 = x - X0;
      y0 = y - Y0;
      z0 = z - Z0;
      w0 = w - W0;
      c1 = (x0 > y0 ? 32 : 0);
      c2 = (x0 > z0 ? 16 : 0);
      c3 = (y0 > z0 ? 8 : 0);
      c4 = (x0 > w0 ? 4 : 0);
      c5 = (y0 > w0 ? 2 : 0);
      c6 = (z0 > w0 ? 1 : 0);
      c = c1 + c2 + c3 + c4 + c5 + c6;
      i1 = 0;
      j1 = 0;
      k1 = 0;
      l1 = 0;
      i2 = 0;
      j2 = 0;
      k2 = 0;
      l2 = 0;
      i3 = 0;
      j3 = 0;
      k3 = 0;
      l3 = 0;
      i1 = (simplex[c][0] >= 3 ? 1 : 0);
      j1 = (simplex[c][1] >= 3 ? 1 : 0);
      k1 = (simplex[c][2] >= 3 ? 1 : 0);
      l1 = (simplex[c][3] >= 3 ? 1 : 0);
      i2 = (simplex[c][0] >= 2 ? 1 : 0);
      j2 = (simplex[c][1] >= 2 ? 1 : 0);
      k2 = (simplex[c][2] >= 2 ? 1 : 0);
      l2 = (simplex[c][3] >= 2 ? 1 : 0);
      i3 = (simplex[c][0] >= 1 ? 1 : 0);
      j3 = (simplex[c][1] >= 1 ? 1 : 0);
      k3 = (simplex[c][2] >= 1 ? 1 : 0);
      l3 = (simplex[c][3] >= 1 ? 1 : 0);
      x1 = x0 - i1 + G4;
      y1 = y0 - j1 + G4;
      z1 = z0 - k1 + G4;
      w1 = w0 - l1 + G4;
      x2 = x0 - i2 + 2.0 * G4;
      y2 = y0 - j2 + 2.0 * G4;
      z2 = z0 - k2 + 2.0 * G4;
      w2 = w0 - l2 + 2.0 * G4;
      x3 = x0 - i3 + 3.0 * G4;
      y3 = y0 - j3 + 3.0 * G4;
      z3 = z0 - k3 + 3.0 * G4;
      w3 = w0 - l3 + 3.0 * G4;
      x4 = x0 - 1.0 + 4.0 * G4;
      y4 = y0 - 1.0 + 4.0 * G4;
      z4 = z0 - 1.0 + 4.0 * G4;
      w4 = w0 - 1.0 + 4.0 * G4;
      ii = i & 255;
      jj = j & 255;
      kk = k & 255;
      ll = l & 255;
      gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
      gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
      gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
      gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
      gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;
      t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (!(t0 < 0)) {
        t0 *= t0;
        n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);
      }
      t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (!(t1 < 0)) {
        t1 *= t1;
        n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);
      }
      t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (!(t2 < 0)) {
        t2 *= t2;
        n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);
      }
      t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (!(t3 < 0)) {
        t3 *= t3;
        n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);
      }
      t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (!(t4 < 0)) {
        t4 *= t4;
        n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);
      }
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    };

    return SimplexNoise;

  })(Noise);

  FlowNoise = (function(_super) {
    var TWO_PI, n;

    __extends(FlowNoise, _super);

    n = 128;

    TWO_PI = Math.PI * 2;

    FlowNoise.prototype.basis = [];

    FlowNoise.prototype.perm = [];

    function FlowNoise(rng) {
      var i, theta, _i;

      if (rng == null) {
        rng = Math;
      }
      for (i = _i = 0; 0 <= n ? _i <= n : _i >= n; i = 0 <= n ? ++_i : --_i) {
        theta = i * TWO_PI / n;
        this.basis[i] = [Math.cos(theta, Math.sin(theta))];
        this.perm[i] = i;
      }
      reinitialize((rng.random() * 1000) | 0);
    }

    FlowNoise.prototype.reinitialize = function(seed) {
      var i, j, _i, _results;

      _results = [];
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        j = (Math.random() * seed) % (i + 1);
        _results.push(seed += 1);
      }
      return _results;
    };

    return FlowNoise;

  })(Noise);

  module.exports = {
    SimplexNoise: SimplexNoise
  };

}).call(this);

},{}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Vec2, Vec3;

  Vec2 = (function() {
    Vec2.prototype.x = 0;

    Vec2.prototype.y = 0;

    function Vec2(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
    }

    Vec2.prototype.set = function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    };

    Vec2.prototype.set2 = function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    };

    Vec2.prototype.zero = function() {
      this.x = this.y = 0;
      return this;
    };

    Vec2.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    };

    Vec2.prototype.add_ = function(v) {
      return new Vec2(this.x + v.x, this.y + v.y);
    };

    Vec2.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    };

    Vec2.prototype.sub_ = function(v) {
      return new Vec2(this.x - v.x, this.y - v.y);
    };

    Vec2.prototype.mul = function(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    };

    Vec2.prototype.mul_ = function(v) {
      return new Vec2(this.x * v.x, this.y * v.y);
    };

    Vec2.prototype.div = function(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    };

    Vec2.prototype.div_ = function(v) {
      return new Vec2(this.x / v.x, this.y / v.y);
    };

    Vec2.prototype.scale = function(value) {
      this.x *= value;
      this.y *= value;
      return this;
    };

    Vec2.prototype.scale_ = function(value) {
      return new Vec2(this.x * value, this.y * value);
    };

    Vec2.prototype.length = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    Vec2.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y;
    };

    Vec2.prototype.normalize = function() {
      var l;

      l = this.length();
      if (l !== 0) {
        this.x /= l;
        this.y /= l;
      }
      return this;
    };

    Vec2.prototype.normalize_ = function() {
      return this.clone().normalize();
    };

    Vec2.prototype.normalizeTo = function(length) {
      var magnitude;

      magnitude = Math.sqrt(this.x * this.x + this.y * this.y);
      if (magnitude > 0) {
        magnitude = length / magnitude;
        this.x *= magnitude;
        this.y *= magnitude;
      }
      return this;
    };

    Vec2.prototype.normalizeTo_ = function(length) {
      return this.clone().normalizeTo_(length);
    };

    Vec2.prototype.distance = function(v) {
      return Math.sqrt(this.distanceSquared2(v.x, v.y));
    };

    Vec2.prototype.distanceSquared = function(v) {
      return this.distanceSquared2(v.x, v.y);
    };

    Vec2.prototype.distanceSquared2 = function(x, y) {
      var dx, dy;

      dx = this.x - x;
      dy = this.y - y;
      return dx * dx + dy * dy;
    };

    Vec2.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Vec2.prototype.rotate = function(angle) {
      var cosa, rx, ry, sina;

      sina = Math.sin(angle);
      cosa = Math.cos(angle);
      rx = this.x * cosa - this.y * sina;
      ry = this.x * sina + this.y * cosa;
      this.x = rx;
      return this.y = ry;
    };

    Vec2.prototype.jitter = function(amount) {
      this.x += (Math.random() * 2 - 1) * amount;
      this.y += (Math.random() * 2 - 1) * amount;
      return this;
    };

    Vec2.prototype.jitter_ = function(amount) {
      return (new Vec2(this.x, this.y)).jitter(amount);
    };

    Vec2.prototype.lerp = function(target, delta) {
      this.x = this.x * (1 - delta) + target.x * delta;
      this.y = this.y * (1 - delta) + target.y * delta;
      return this;
    };

    Vec2.prototype.lerp_ = function(target, delta) {
      return (new Vec2(this.x, this.y)).lerp(target, delta);
    };

    Vec2.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y;
    };

    Vec2.prototype.clone = function() {
      return new Vec2(this.x, this.y);
    };

    Vec2.prototype.toString = function() {
      return "Vec2(" + this.x + ", " + this.y + ")";
    };

    return Vec2;

  })();

  Vec3 = (function() {
    Vec3.prototype.x = 0;

    Vec3.prototype.y = 0;

    Vec3.prototype.z = 0;

    function Vec3(x, y, z) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.z = z != null ? z : 0;
    }

    Vec3.prototype.set = function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    };

    Vec3.prototype.set3 = function(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    };

    Vec3.prototype.zero = function() {
      this.x = this.y = this.z = 0;
      return this;
    };

    Vec3.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    };

    Vec3.prototype.add_ = function(v) {
      return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
    };

    Vec3.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    };

    Vec3.prototype.sub_ = function(v) {
      return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
    };

    Vec3.prototype.mul = function(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    };

    Vec3.prototype.mul_ = function(v) {
      return new Vec3(this.x * v.x, this.y * v.y, this.z * v.z);
    };

    Vec3.prototype.div = function(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    };

    Vec3.prototype.div_ = function(v) {
      return new Vec3(this.x / v.x, this.y / v.y, this.z = v.z);
    };

    Vec3.prototype.scale = function(value) {
      this.x *= value;
      this.y *= value;
      this.z *= value;
      return this;
    };

    Vec3.prototype.scale_ = function(value) {
      return new Vec3(this.x * value, this.y * value, this.z * value);
    };

    Vec3.prototype.length = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    Vec3.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Vec3.prototype.normalize = function() {
      var l;

      l = this.length();
      if (l !== 0) {
        this.x /= l;
        this.y /= l;
        this.z /= l;
      }
      return this;
    };

    Vec3.prototype.normalize_ = function() {
      return this.clone().normalize();
    };

    Vec3.prototype.normalizeTo = function(length) {
      var magnitude;

      magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      if (magnitude > 0) {
        magnitude = length / magnitude;
        this.x *= magnitude;
        this.y *= magnitude;
      }
      return this;
    };

    Vec3.prototype.normalizeTo_ = function(length) {
      return this.clone().normalizeTo_(length);
    };

    Vec3.prototype.distance = function(v) {
      return Math.sqrt(this.distanceSquared3(v.x, v.y, v.z));
    };

    Vec3.prototype.distanceSquared = function(v) {
      return this.distanceSquared3(v.x, v.y, v.z);
    };

    Vec3.prototype.distanceSquared3 = function(x, y, z) {
      var dx, dy, dz;

      dx = this.x - x;
      dy = this.y - y;
      dz = this.z - z;
      return dx * dx + dy * dy + dz * dz;
    };

    Vec3.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    };

    Vec3.prototype.jitter = function(amount) {
      this.x += (Math.random() * 2 - 1) * amount;
      this.y += (Math.random() * 2 - 1) * amount;
      this.z += (Math.random() * 2 - 1) * amount;
      return this;
    };

    Vec3.prototype.jitter_ = function(amount) {
      return (new Vec3(this.x, this.y, this.z)).jitter(amount);
    };

    Vec3.prototype.lerp = function(target, delta) {
      this.x = this.x * (1 - delta) + target.x * delta;
      this.y = this.y * (1 - delta) + target.y * delta;
      this.z = this.z * (1 - delta) + target.z * delta;
      return this;
    };

    Vec3.prototype.lerp_ = function(target, delta) {
      return (new Vec3(this.x, this.y, this.z)).lerp(target, delta);
    };

    Vec3.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z;
    };

    Vec3.prototype.clone = function() {
      return new Vec3(this.x, this.y, this.z);
    };

    Vec3.prototype.toString = function() {
      return "Vec3(" + this.x + ", " + this.y + ", " + this.z + ")";
    };

    return Vec3;

  })();

  module.exports = {
    Vec2: Vec2,
    Vec3: Vec3
  };

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Tempo, Time, Timer, Timespan, math, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('./util');

  math = require('./math/math');

  /*
    Timer: keeps track of time, measures intervals etc.
    ------------------------------------------------------------------------------
  */


  Timer = (function() {
    Timer.prototype.now = null;

    Timer.prototype.prev = null;

    function Timer() {
      this.reset();
    }

    Timer.prototype.update = function() {
      var dt;

      this.now = Date.now();
      dt = this.now - this.prev;
      this.prev = this.now;
      return dt;
    };

    Timer.prototype.elapsed = function() {
      return Date.now() - this.prev;
    };

    Timer.prototype.reset = function() {
      return this.now = this.prev = Date.now();
    };

    return Timer;

  })();

  /*
    Tempo: keeps track of rhythm, converts between beats, bars, time, tempo etc
    ------------------------------------------------------------------------------
  */


  Tempo = (function() {
    Tempo.prototype.bpm = 120;

    Tempo.prototype.sigNum = 4;

    Tempo.prototype.sigDenom = 4;

    Tempo.prototype.resolution = 32;

    Tempo.prototype.beatInterval = 0;

    Tempo.prototype.gridInterval = 0;

    Tempo.prototype.time = 0;

    Tempo.prototype.prevEvent = 0;

    Tempo.prototype.beats = 0;

    Tempo.prototype.bars = 0;

    Tempo.prototype.beat = 0;

    Tempo.prototype.onBeat = false;

    Tempo.prototype.onBar = false;

    Tempo.prototype.on64 = false;

    Tempo.prototype.on32 = false;

    Tempo.prototype.on16 = false;

    Tempo.prototype.on8 = false;

    Tempo.prototype.on4 = false;

    Tempo.prototype.on2 = false;

    function Tempo(bpm, sigNum, sigDenom, resolution) {
      this.bpm = bpm != null ? bpm : 120;
      this.sigNum = sigNum != null ? sigNum : 4;
      this.sigDenom = sigDenom != null ? sigDenom : 4;
      this.resolution = resolution != null ? resolution : 32;
      this.reset();
    }

    Tempo.prototype.reset = function() {
      this.beatInterval = 1000 / (this.bpm / 60);
      this.gridInterval = this.beatInterval * this.sigNum / this.resolution;
      this.time = this.prevEvent = 0;
      this.beats = 0;
      this.beat = this.bars = 0;
      this.onBeat = this.onBar = false;
      return this.on64 = this.on32 = this.on16 = this.on8 = this.on4 = this.on2 = false;
    };

    Tempo.prototype.update = function(dt) {
      var forceOnGrid;

      forceOnGrid = this.time - this.prevEvent >= this.gridInterval;
      this.setTime(this.time + dt, forceOnGrid);
      return this.beat;
    };

    Tempo.prototype.setTime = function(time, forceOnGrid) {
      var gridUnits, r, u;

      this.time = time;
      if (this.time % this.gridInterval === 0 || forceOnGrid) {
        this.prevEvent = time;
        gridUnits = Math.floor(this.time / this.gridInterval);
        u = gridUnits;
        r = this.resolution;
        this.beats = Math.floor(this.time / this.beatInterval);
        this.bars = Math.floor(this.beats / this.sigDenom);
        this.beat = this.beats % this.sigNum;
        this.onBeat = u % (r / this.sigNum) === 0;
        this.onBar = (u % this.resolution) === 0;
        this.on64 = u % (r / 64) === 0;
        this.on32 = u % (r / 32) === 0;
        this.on16 = u % (r / 16) === 0;
        this.on8 = u % (r / 8) === 0;
        this.on4 = u % (r / 4) === 0;
        this.on2 = u % (r / 2) === 0;
      } else {
        this.onBeat = this.onBar = false;
        this.on64 = this.on32 = this.on16 = this.on8 = this.on4 = this.on2 = false;
      }
      return this.beat;
    };

    return Tempo;

  })();

  /*
    Time: Represents a single moment in time
    ------------------------------------------------------------------------------
  */


  Time = (function(_super) {
    __extends(Time, _super);

    Time.prototype.value = 0;

    function Time(arg, fps, tempo) {
      this.set(arg, fps, tempo);
    }

    Time.prototype.set = function(arg, fps, tempo) {
      if (arg == null) {
        arg = 0;
      }
      return this.value = (function() {
        switch (typeof arg) {
          case 'number':
            return arg;
          case 'string':
            return this["eval"](arg, fps, tempo);
          default:
            return arg.value;
        }
      }).call(this);
    };

    Time.prototype.add = function(time) {
      return this.value += typeof time === 'number' ? time : time.value;
    };

    Time.prototype.add_ = function(time) {
      return new Time(this.value + (typeof time === 'number' ? time : time.value));
    };

    Time.prototype.sub = function(time) {
      return this.time -= typeof time === 'number' ? time : time.value;
    };

    Time.prototype.sub_ = function(time) {
      return new Time(this.value - (typeof time === 'number' ? time : time.value));
    };

    Time.prototype.scale = function(factor) {
      return this.value *= factor;
    };

    Time.prototype.scale_ = function(factor) {
      return new Time(this.value * factor);
    };

    Time.prototype.clone = function() {
      return new Time(this.value);
    };

    Time.prototype.equals = function(time) {
      return this.value === (typeof time === 'number' ? time : time.value);
    };

    Time.prototype.toString = function() {
      return "" + this.value + "ms";
    };

    Time.prototype.normalizedTo = function(span) {
      return math.fit(this.value, span.from.value, span.to.value, 0, 1);
    };

    Time.set('s', function(seconds) {
      return this.value = seconds * 1000;
    });

    Time.get('s', function() {
      return this.value / 1000;
    });

    Time.prototype.toFrame = function(fps) {
      if (fps == null) {
        fps = 60;
      }
      return Math.floor(this.value / (1000 / fps));
    };

    Time.prototype["eval"] = function(string, fps, tempo) {
      var interval, re, unit, units, _i, _len;

      if (tempo == null) {
        tempo = null;
      }
      units = [
        {
          symbol: 'ms',
          factor: 1
        }, {
          symbol: 's',
          factor: 1000
        }, {
          symbol: 'm',
          factor: 60000
        }, {
          symbol: 'f',
          factor: 1000 / fps
        }
      ];
      if (tempo != null) {
        interval = tempo.gridInterval;
        units.push({
          symbol: 'i',
          factor: interval
        });
        units.push({
          symbol: 'n',
          factor: interval * tempo.resolution
        });
      }
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        unit = units[_i];
        re = new RegExp("\\d+(?=" + unit.symbol + ")", "g");
        string = string.replace(re, function(value) {
          return value * unit.factor;
        });
        re = new RegExp(unit.symbol, "g");
        string = string.replace(re, '');
      }
      return eval(string);
    };

    Time.s = function(seconds) {
      return new Time(seconds * 1000);
    };

    Time.ms = function(milliseconds) {
      return new Time(milliseconds);
    };

    Time.f = function(frame, fps) {
      return new Time(frame / (1000 / fps));
    };

    Time.i = function(intervals, tempo) {
      return new Time(intervals * tempo.gridInterval);
    };

    Time.str = function(string, fps, tempo) {
      return new Time(string, fps, tempo);
    };

    return Time;

  })(util.EXObject);

  /*
    Timespan: Represents a duration of time between two moments
    ------------------------------------------------------------------------------
  */


  Timespan = (function(_super) {
    __extends(Timespan, _super);

    function Timespan() {
      switch (arguments.length) {
        case 0:
          this.from = new Time(0);
          this.to = new Time(0);
          break;
        case 1:
          this.from = new Time(0);
          this.to = new Time(arguments[0]);
          break;
        case 2:
          this.from = new Time(arguments[0]);
          this.to = new Time(arguments[1]);
      }
    }

    Timespan.prototype.segmentByInterval = function(interval, snapEnd) {
      var current, halfInterval, last, segments;

      if (snapEnd == null) {
        snapEnd = false;
      }
      interval = typeof interval === 'number' ? new Time(interval) : interval;
      segments = [];
      current = new Timespan(this.from, this.from.add_(interval));
      segments.push(current.clone());
      while (current.to.value < this.to.value) {
        current.from.add(interval);
        current.to.add(interval);
        segments.push(current.clone());
      }
      if (snapEnd && segments.length > 0) {
        last = segments[segments.length - 1];
        halfInterval = interval.scale_(0.5);
        if (this.to.value - last.to.value > halfInterval) {
          segments.push(new Timespan(last.clone(), this.to.clone()));
        } else {
          last.to.value = this.to.value;
        }
      }
      return segments;
    };

    Timespan.prototype.overlaps = function(other) {
      var from, from2, to, to2;

      from = this.from.value;
      to = this.to.value;
      from2 = other.from.value;
      to2 = other.to.value;
      return (to2 >= from && to2 <= to) || (from2 >= from && from2 <= to) || (from2 <= from && to2 >= to);
    };

    Timespan.prototype.clone = function() {
      return new Timespan(this.from, this.to);
    };

    Timespan.prototype.toString = function() {
      return "Timespan(" + this.from + " - " + this.to + ")";
    };

    Timespan.set('length', function(length) {
      return this.to.value = this.from.value + length;
    });

    Timespan.get('length', function() {
      return new Time(this.to.value - this.from.value);
    });

    Timespan.get('s', function() {
      return this.length.s;
    });

    Timespan.s = function(seconds) {
      return new Timespan(seconds * 1000);
    };

    Timespan.str = function(string, fps, tempo) {
      var from, times, to;

      times = string.split('..');
      if (times.length !== 2) {
        throw "Invalid argument: " + string;
      }
      from = Time.str(times[0], fps, tempo);
      to = Time.str(times[1], fps, tempo);
      return new Timespan(from, to);
    };

    return Timespan;

  })(util.EXObject);

  module.exports = {
    Timer: Timer,
    Tempo: Tempo,
    Time: Time,
    Timespan: Timespan
  };

}).call(this);

},{"./util":2,"./math/math":5}],16:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":17}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var random, randomPkg;

  randomPkg = require('./random');

  random = new randomPkg.Random();

  module.exports = {
    fit: function(value, inMin, inMax, outMin, outMax) {
      value = Math.max(inMin, Math.min(inMax, value));
      return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
    },
    fit01: function(value, min, max) {
      return value * (max - min) + min;
    },
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    clamp01: function(value) {
      return Math.max(0, Math.min(1, value));
    },
    randf: function(min, max) {
      return random.randf(min, max);
    },
    randi: function(min, max) {
      return random.randi(min, max);
    },
    flipCoin: function(chance) {
      return random.flipCoin(chance);
    },
    round: function(value, decimals) {
      var exp;

      if (decimals == null) {
        decimals = 0;
      }
      if (decimals === 0) {
        return Math.round(value);
      } else {
        exp = Math.pow(10, decimals);
        return Math.round(value * exp) / exp;
      }
    },
    interpolate: {
      spherical: function(current, target, delta) {
        return current * (1.0 - delta) + target * delta;
      },
      linear: function(current, target, delta) {
        return current + (target - current) * delta;
      }
    },
    /*
      Easing Functions - inspired by http://easings.net
      only considering the t value for the range [0, 1] => [0, 1]
    */

    ease: {
      linear: function(t) {
        return t;
      },
      inQuad: function(t) {
        return Math.pow(t, 2);
      },
      outQuad: function(t) {
        return -(Math.pow(t - 1, 2) - 1);
      },
      inOutQuad: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(t, 2);
        }
        return -0.5 * ((t -= 2) * t - 2);
      },
      inCubic: function(t) {
        return Math.pow(t, 3);
      },
      outCubic: function(t) {
        return Math.pow(t - 1, 3) + 1;
      },
      inOutCubic: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(t, 3);
        }
        return 0.5 * (Math.pow(t - 2, 3) + 2);
      },
      inQuart: function(t) {
        return Math.pow(t, 4);
      },
      outQuart: function(t) {
        return -(Math.pow(t - 1, 4) - 1);
      },
      inOutQuart: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(t, 4);
        }
        return -0.5 * ((t -= 2) * Math.pow(t, 3) - 2);
      },
      inQuint: function(t) {
        return Math.pow(t, 5);
      },
      outQuint: function(t) {
        return Math.pow(t - 1, 5) + 1;
      },
      inOutQuint: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(t, 5);
        }
        return 0.5 * (Math.pow(t - 2, 5) + 2);
      },
      inSine: function(t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      outSine: function(t) {
        return Math.sin(t * (Math.PI / 2));
      },
      inOutSine: function(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      inExpo: function(t) {
        if (t === 0) {
          return 0;
        } else {
          return Math.pow(2, 10 * (t - 1));
        }
      },
      outExpo: function(t) {
        if (t === 1) {
          return 1;
        } else {
          return -Math.pow(2, -10 * t) + 1;
        }
      },
      inOutExpo: function(t) {
        if (t === 0) {
          return 0;
        }
        if (t === 1) {
          return 1;
        }
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }
        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      inCirc: function(t) {
        return -(Math.sqrt(1 - (t * t)) - 1);
      },
      outCirc: function(t) {
        return Math.sqrt(1 - Math.pow(t - 1, 2));
      },
      inOutCirc: function(t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      outBounce: function(t) {
        if (t < (1 / 2.75)) {
          return 7.5625 * t * t;
        } else if (t < (2 / 2.75)) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        } else if (t < (2.5 / 2.75)) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        } else {
          return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
      },
      inBack: function(t) {
        var s;

        s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      outBack: function(t) {
        var s;

        s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      inOutBack: function(t) {
        var s;

        s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }
        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      elastic: function(t) {
        return -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1;
      },
      swingFromTo: function(t) {
        var s;

        s = 1.70158;
        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        } else {
          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        }
      },
      swingFrom: function(t) {
        var s;

        s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      swingTo: function(t) {
        var s;

        s = 1.70158;
        return (t -= 1) * t * ((s + 1) * t + s) + 1;
      },
      bounce: function(t) {
        if (t < (1 / 2.75)) {
          return 7.5625 * t * t;
        } else if (t < (2 / 2.75)) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        } else if (t < (2.5 / 2.75)) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        } else {
          return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
      },
      bouncePast: function(t) {
        if (t < (1 / 2.75)) {
          return 7.5625 * t * t;
        } else if (t < (2 / 2.75)) {
          return 2 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75);
        } else if (t < (2.5 / 2.75)) {
          return 2 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375);
        } else {
          return 2 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375);
        }
      },
      fromTo: function(t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(t, 4);
        }
        return -0.5 * ((t -= 2) * Math.pow(t, 3) - 2);
      },
      from: function(t) {
        return Math.pow(t, 4);
      },
      to: function(t) {
        return Math.pow(t, 0.25);
      }
    }
  };

}).call(this);

},{"./random":6}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Rect, Vec2;

  Vec2 = require("./vector").Vec2;

  Rect = (function() {
    Rect.prototype.x1 = 0;

    Rect.prototype.y1 = 0;

    Rect.prototype.x2 = 0;

    Rect.prototype.y2 = 0;

    function Rect(x1, y1, x2, y2) {
      this.x1 = x1 != null ? x1 : 0;
      this.y1 = y1 != null ? y1 : 0;
      this.x2 = x2 != null ? x2 : 0;
      this.y2 = y2 != null ? y2 : 0;
    }

    Rect.prototype.center = function() {
      var x, y;

      x = Math.min(this.x1, this.x2) + this.width() * 0.5;
      y = Math.min(this.y1, this.y2) + this.height() * 0.5;
      return new Vec2(x, y);
    };

    Rect.prototype.width = function() {
      return Math.abs(this.x1 - this.x2);
    };

    Rect.prototype.height = function() {
      return Math.abs(this.y1 - this.y2);
    };

    return Rect;

  })();

  module.exports.Rect = Rect;

}).call(this);

},{"./vector":8}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Behaviour, Constraint, Emitter, Particle, Physics, Space, Spring, particleModule, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('../util');

  particleModule = require('./particle');

  Particle = particleModule.Particle;

  /*
  
    A Particle Physics Simulation
  */


  Physics = (function() {
    Physics.prototype.particles = [];

    Physics.prototype.springs = [];

    Physics.prototype.behaviours = [];

    Physics.prototype.constraints = [];

    Physics.prototype.emitter = null;

    Physics.prototype.space = null;

    Physics.prototype.constraintIterations = 1;

    Physics.prototype.springIterations = 1;

    function Physics() {
      this.space = new Space();
      this.emitter = new Emitter(this);
      this.clear();
    }

    Physics.prototype.clear = function() {
      this.particles = [];
      this.behaviours = [];
      return this.constraints = [];
    };

    Physics.prototype.add = function() {
      var arg, state;

      if (arguments.length === 0) {
        return;
      }
      arg = arguments[0];
      if (arg instanceof Particle) {
        this.addParticle(arg);
      } else if (arg instanceof Behaviour) {
        console.log("adding behaviour " + arg);
        if (arguments.length > 1) {
          state = arguments[1];
        }
        this.addBehaviour(arg, state);
      } else if (arg instanceof Spring) {
        console.log("adding spring " + arg);
        this.addSpring(arg);
      } else {
        "Cannot add " + arg;
      }
      return arg;
    };

    Physics.prototype.addParticle = function(particle) {
      this.particles.push(particle);
      return particle;
    };

    Physics.prototype.addSpring = function(spring) {
      this.springs.push(spring);
      return spring;
    };

    Physics.prototype.addBehaviour = function(effector, state) {
      var list;

      if (state == null) {
        state = particleModule.State.ALIVE;
      }
      list = effector instanceof Constraint ? this.constraints : this.behaviours;
      if (!list[state]) {
        list[state] = [];
      }
      return list[state].push(effector);
    };

    Physics.prototype.update = function() {
      var dead, i, j, particle, particles, spring, stateDead, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;

      this.emitter.update();
      this.space.update(this);
      particles = this.particles;
      this.applyEffectors(this.behaviours, particles);
      for (j = _i = 0, _ref = this.constraintIterations; 0 <= _ref ? _i <= _ref : _i >= _ref; j = 0 <= _ref ? ++_i : --_i) {
        this.applyEffectors(this.constraints, particles);
        for (i = _j = 0, _ref1 = this.springIterations; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.springs;
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            spring = _ref2[_k];
            spring.update();
          }
        }
      }
      dead = [];
      stateDead = particleModule.State.DEAD;
      for (_l = 0, _len1 = particles.length; _l < _len1; _l++) {
        particle = particles[_l];
        particle.update();
        if (particle.state === stateDead) {
          dead.push(particle);
        }
        void 0;
      }
      i = dead.length;
      while (i--) {
        particle = dead[i];
        util.removeElement(particle, particles);
        void 0;
      }
      return void 0;
    };

    Physics.prototype.applyEffectors = function(effectors, particles) {
      var effector, particle, state, stateEffectors, _i, _j, _len, _len1;

      state = effectors.length;
      while (state--) {
        stateEffectors = effectors[state];
        for (_i = 0, _len = stateEffectors.length; _i < _len; _i++) {
          effector = stateEffectors[_i];
          effector.prepare(this);
          for (_j = 0, _len1 = particles.length; _j < _len1; _j++) {
            particle = particles[_j];
            if (particle.state === state && !particle.isLocked) {
              effector.apply(particle);
            }
            void 0;
          }
          void 0;
        }
        void 0;
      }
      return void 0;
    };

    Physics.prototype.size = function() {
      return this.particles.length;
    };

    return Physics;

  })();

  /*
    Spatial Search
  
    Simple brute force spatial searches.
    Subclasses may override this to organise particles so they can be found quicker later
  */


  Space = (function() {
    var physics;

    physics = null;

    function Space() {}

    Space.prototype.update = function(physics_) {
      return physics = physics_;
    };

    Space.prototype.search = function(center, radius) {
      var particle, radiusSq, result, _i, _len, _ref;

      result = [];
      radiusSq = radius * radius;
      _ref = physics.particles;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        particle = _ref[_i];
        if (center.distanceSquared(particle.position) < radiusSq) {
          result.push(particle);
        }
      }
      return result;
    };

    return Space;

  })();

  /*
    Particle Emitter
  */


  Emitter = (function() {
    var id, timer;

    Emitter.prototype.rate = 1;

    Emitter.prototype.interval = 1;

    Emitter.prototype.max = 100;

    Emitter.prototype.type = particleModule.Particle3;

    timer = -1;

    id = 0;

    function Emitter(physics) {
      this.physics = physics;
    }

    Emitter.prototype.update = function() {
      var i, p;

      if (timer === -1 || timer >= this.interval) {
        timer = 0;
        i = 0;
        while (i < this.rate && this.physics.size() < this.max) {
          p = this.create();
          this.init(p);
          i++;
        }
      }
      return timer++;
    };

    Emitter.prototype.create = function() {
      var p;

      p = new this.type(id++);
      this.physics.addParticle(p);
      return p;
    };

    Emitter.prototype.init = function(particle) {};

    return Emitter;

  })();

  /*
    Base class for all physical forces, behaviours & constraints
  */


  Behaviour = (function() {
    function Behaviour() {}

    Behaviour.prototype.prepare = function() {};

    Behaviour.prototype.apply = function(particle) {};

    return Behaviour;

  })();

  Constraint = (function(_super) {
    __extends(Constraint, _super);

    function Constraint() {
      _ref = Constraint.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Constraint.prototype.prepare = function() {};

    Constraint.prototype.apply = function(particle) {};

    return Constraint;

  })(Behaviour);

  /*
    Verlet Spring
  */


  Spring = (function() {
    Spring.prototype.a = null;

    Spring.prototype.b = null;

    Spring.prototype.restLength = 0;

    Spring.prototype.strength = 0.5;

    function Spring(a, b, strength) {
      this.a = a;
      this.b = b;
      this.strength = strength != null ? strength : 0.5;
      this.restLength = this.a.position.distance(this.b.position);
    }

    Spring.prototype.update = function() {
      var delta, dist, normDistStrength;

      delta = this.b.position.sub_(this.a.position);
      dist = delta.length() + Number.MIN_VALUE;
      normDistStrength = (dist - this.restLength) / dist * this.strength;
      if (normDistStrength === 0) {
        return;
      }
      delta.scale(normDistStrength);
      if (!this.a.isLocked) {
        this.a.position.add(delta);
      }
      if (!this.b.isLocked) {
        return this.b.position.sub(delta);
      }
    };

    Spring.prototype.toString = function() {
      return "Spring(" + a + ", " + b + ")";
    };

    return Spring;

  })();

  module.exports = {
    Physics: Physics,
    Emitter: Emitter,
    Space: Space,
    Behaviour: Behaviour,
    Constraint: Constraint,
    Spring: Spring
  };

}).call(this);

},{"../util":2,"./particle":11}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Particle, Particle2, Particle3, State, Vec2, Vec3, vector,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  vector = require('../math/vector');

  Vec2 = vector.Vec2;

  Vec3 = vector.Vec3;

  State = {
    ALIVE: 0,
    LOCKED: 1,
    IDLE: 2,
    DEAD: 3
  };

  /*
  
    VerLer Particle Baseclass
  
    FIELD flavoured particle integrator.
    Supports Verlet-style integration for 'strict' relationships e.g. Springs + Constraints
    and also Euler-style continous force integration for smooth/ flowing behaviour e.g. Flocking
  */


  Particle = (function() {
    Particle.prototype.id = 0;

    Particle.prototype.state = State.ALIVE;

    Particle.prototype.age = 0;

    Particle.prototype.lifetime = -1;

    Particle.prototype.size = 1;

    Particle.prototype.isLocked = false;

    Particle.prototype.position = null;

    Particle.prototype.drag = 0.03;

    Particle.prototype.prev = null;

    Particle.prototype.force = null;

    Particle.prototype.velocity = null;

    function Particle(id) {
      this.id = id;
    }

    Particle.prototype.clearVelocity = function() {
      return this.prev.set(this.position);
    };

    Particle.prototype.scaleVelocity = function(amount) {
      return this.prev.lerp(this.position, 1.0 - amount);
    };

    Particle.prototype.setPosition = function(v) {
      this.position.set(v);
      return this.prev.set(v);
    };

    Particle.prototype.lock = function() {
      return this.state = State.LOCKED;
    };

    Particle.prototype.unlock = function() {
      return this.state = State.ALIVE;
    };

    Particle.prototype.die = function() {
      return this.state = State.DEAD;
    };

    Particle.prototype.idle = function() {
      return this.state = State.IDLE;
    };

    Particle.prototype.toString = function() {
      return "Particle(" + this.position + ")";
    };

    return Particle;

  })();

  /*
  
    3D VerLer Particle
  */


  Particle3 = (function(_super) {
    var tmp;

    __extends(Particle3, _super);

    tmp = new Vec3();

    function Particle3(id) {
      this.id = id;
      this.position = new Vec3();
      this.prev = new Vec3();
      this.force = new Vec3();
      this.velocity = new Vec3();
    }

    Particle3.prototype.update = function() {
      this.age++;
      if (this.state > State.ALIVE) {
        return;
      }
      if (this.lifetime > 0 && this.age === this.lifetime) {
        this.state = State.DEAD;
      }
      tmp.set(this.position);
      this.position.x += (this.position.x - this.prev.x) + this.force.x;
      this.position.y += (this.position.y - this.prev.y) + this.force.y;
      this.position.z += (this.position.z - this.prev.z) + this.force.z;
      this.prev.set(tmp);
      this.prev.lerp(this.position, this.drag);
      return this.force.zero();
    };

    Particle3.prototype.setPosition3 = function(x, y, z) {
      this.position.set3(x, y, z);
      return this.prev.set3(x, y, z);
    };

    return Particle3;

  })(Particle);

  /*
  
    2D VerLer Particle
  */


  Particle2 = (function(_super) {
    var tmp;

    __extends(Particle2, _super);

    tmp = new Vec2();

    function Particle2(id) {
      this.id = id;
      this.position = new Vec2();
      this.prev = new Vec2();
      this.force = new Vec2();
      this.velocity = new Vec2();
    }

    Particle2.prototype.update = function() {
      this.age++;
      if (this.state > State.ALIVE) {
        return;
      }
      if (this.lifetime > 0 && this.age === this.lifetime) {
        this.state = State.DEAD;
      }
      tmp.set(this.position);
      this.position.x += (this.position.x - this.prev.x) + this.force.x;
      this.position.y += (this.position.y - this.prev.y) + this.force.y;
      this.prev.set(tmp);
      this.prev.lerp(this.position, this.drag);
      return this.force.zero();
    };

    Particle2.prototype.setPosition2 = function(x, y) {
      this.position.set2(x, y);
      return this.prev.set2(x, y);
    };

    return Particle2;

  })(Particle);

  module.exports = {
    Particle: Particle,
    Particle2: Particle2,
    Particle3: Particle3,
    State: State
  };

}).call(this);

},{"../math/vector":8}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Attractor, Behaviour, Force, Vec2, Vec3, physics, vector,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  vector = require('../math/vector');

  Vec2 = vector.Vec2;

  Vec3 = vector.Vec3;

  physics = require('./physics');

  Behaviour = physics.Behaviour;

  /*
  
    A constant force along a vector e.g. Gravity.
    Works in 2D + 3D.
  */


  Force = (function(_super) {
    var force;

    __extends(Force, _super);

    force = null;

    function Force(direction, weight) {
      this.direction = direction;
      this.weight = weight != null ? weight : 1;
    }

    Force.prototype.prepare = function() {
      return force = this.direction.normalizeTo(this.weight);
    };

    Force.prototype.apply = function(particle) {
      return particle.position.add(force);
    };

    Force.prototype.toString = function() {
      return "Force(" + force + ")";
    };

    return Force;

  })(Behaviour);

  /*
  
    Attracts each particle within range to a target point.
    Works in 2D + 3D.
  */


  Attractor = (function() {
    var rangeSq, tmp;

    tmp = null;

    rangeSq = 0;

    function Attractor(target, range, weight) {
      this.target = target;
      this.range = range;
      this.weight = weight != null ? weight : 1;
      tmp = this.target.clone();
    }

    Attractor.prototype.prepare = function() {
      return rangeSq = this.range * this.range;
    };

    Attractor.prototype.apply = function(particle) {
      var dist, distSq;

      tmp.set(this.target).sub(particle.position);
      distSq = tmp.lengthSquared();
      if (distSq > 0 && distSq < rangeSq) {
        dist = Math.sqrt(distSq);
        tmp.scale((1 / dist) * (1 - dist / this.range) * this.weight);
        return particle.force.add(tmp);
      }
    };

    Attractor.prototype.toString = function() {
      return "Attractor(" + this.target + ", " + this.range + ", " + this.weight + ")";
    };

    return Attractor;

  })();

  module.exports = {
    Force: Force,
    Attractor: Attractor
  };

}).call(this);

},{"../math/vector":8,"./physics":10}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Area, Box, Collision, Constraint, Vec2, Vec3, Wrap2, Wrap3, physics, vector,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  vector = require('../math/vector');

  Vec2 = vector.Vec2;

  Vec3 = vector.Vec3;

  physics = require('./physics');

  Constraint = physics.Constraint;

  /*
    Keeps the particle inside the given 3D box
  */


  Box = (function(_super) {
    __extends(Box, _super);

    function Box(min, max) {
      this.min = min != null ? min : new Vec3();
      this.max = max != null ? max : new Vec3(100, 100, 100);
    }

    Box.prototype.apply = function(particle) {
      var pos;

      pos = particle.position;
      if (pos.x < this.min.x) {
        pos.x = this.min.x;
      }
      if (pos.y < this.min.y) {
        pos.y = this.min.y;
      }
      if (pos.z < this.min.z) {
        pos.z = this.min.z;
      }
      if (pos.x > this.max.x) {
        pos.x = this.max.x;
      }
      if (pos.y > this.max.y) {
        pos.y = this.max.y;
      }
      if (pos.z > this.max.z) {
        return pos.z = this.max.z;
      }
    };

    Box.prototype.toString = function() {
      return "Box(" + this.min + ", " + this.max + ")";
    };

    return Box;

  })(Constraint);

  /*
    2D version of Box.
  */


  Area = (function(_super) {
    __extends(Area, _super);

    function Area(min, max) {
      this.min = min != null ? min : new Vec2();
      this.max = max != null ? max : new Vec2(100, 100);
    }

    Area.prototype.apply = function(particle) {
      var pos;

      pos = particle.position;
      if (pos.x < this.min.x) {
        pos.x = this.min.x;
      }
      if (pos.y < this.min.y) {
        pos.y = this.min.y;
      }
      if (pos.x > this.max.x) {
        pos.x = this.max.x;
      }
      if (pos.y > this.max.y) {
        return pos.y = this.max.y;
      }
    };

    Area.prototype.toString = function() {
      return "Area(" + this.min + ", " + this.max + ")";
    };

    return Area;

  })(Constraint);

  /*
    Keeps a particle within a certain 2D region by wrapping it around a given area.
  */


  Wrap2 = (function(_super) {
    var delta;

    __extends(Wrap2, _super);

    delta = new Vec2();

    function Wrap2(min, max) {
      this.min = min != null ? min : new Vec2();
      this.max = max != null ? max : new Vec2(100, 100);
    }

    Wrap2.prototype.prepare = function() {
      return delta.set(this.max).sub(this.min);
    };

    Wrap2.prototype.apply = function(particle) {
      var pos, prev;

      pos = particle.position;
      prev = particle.prev;
      if (pos.x < this.min.x) {
        pos.x += delta.x;
        prev.x += delta.x;
      }
      if (pos.y < this.min.y) {
        pos.y += delta.y;
        prev.y += delta.y;
      }
      if (pos.x > this.max.x) {
        pos.x -= delta.x;
        prev.x -= delta.x;
      }
      if (pos.y > this.max.y) {
        pos.y -= delta.y;
        return prev.y -= delta.y;
      }
    };

    Wrap2.prototype.toString = function() {
      return "Wrap2(" + this.min + ", " + this.max + ")";
    };

    return Wrap2;

  })(Constraint);

  /*
    Keeps a particle within a certain 2D region by wrapping it around a given area.
  */


  Wrap3 = (function(_super) {
    var delta;

    __extends(Wrap3, _super);

    delta = new Vec3();

    function Wrap3(min, max) {
      this.min = min != null ? min : new Vec3();
      this.max = max != null ? max : new Vec3(100, 100, 100);
    }

    Wrap3.prototype.prepare = function() {
      return delta.set(this.max).sub(this.min);
    };

    Wrap3.prototype.apply = function(particle) {
      var pos, prev;

      pos = particle.position;
      prev = particle.prev;
      if (pos.x < this.min.x) {
        pos.x += delta.x;
        prev.x += delta.x;
      }
      if (pos.y < this.min.y) {
        pos.y += delta.y;
        prev.y += delta.y;
      }
      if (pos.z < this.min.z) {
        pos.z += delta.z;
        prev.z += delta.z;
      }
      if (pos.x > this.max.x) {
        pos.x -= delta.x;
        prev.x -= delta.x;
      }
      if (pos.y > this.max.y) {
        pos.y -= delta.y;
        prev.y -= delta.y;
      }
      if (pos.z > this.max.z) {
        pos.z -= delta.z;
        return prev.z -= delta.z;
      }
    };

    Wrap3.prototype.toString = function() {
      return "Wrap3(" + this.min + ", " + this.max + ")";
    };

    return Wrap3;

  })(Constraint);

  /*
    Stops particles from colliding with each other.
  */


  Collision = (function(_super) {
    __extends(Collision, _super);

    Collision.prototype.physics = null;

    Collision.prototype.searchRadius = 100;

    function Collision(physics) {
      this.physics = physics;
    }

    Collision.prototype.apply = function(particle) {
      var delta, dist, distSq, neighbour, neighbours, position, radius, radiusSq, _i, _len;

      position = particle.position;
      delta = position.clone();
      neighbours = this.physics.space.search(position, this.searchRadius);
      for (_i = 0, _len = neighbours.length; _i < _len; _i++) {
        neighbour = neighbours[_i];
        if (neighbour === particle) {
          continue;
        }
        delta.set(position).sub(neighbour.position);
        distSq = delta.lengthSquared();
        radius = particle.size + neighbour.size;
        radiusSq = radius * radius;
        if (distSq < radiusSq) {
          dist = Math.sqrt(distSq);
          delta.scale((dist - radius) / radius * 0.5);
          particle.position.sub(delta);
          neighbour.position.add(delta);
        }
        void 0;
      }
      return void 0;
    };

    return Collision;

  })(Constraint);

  module.exports = {
    Box: Box,
    Area: Area,
    Wrap2: Wrap2,
    Wrap3: Wrap3,
    Collision: Collision
  };

}).call(this);

},{"../math/vector":8,"./physics":10}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
(function() {
  var Color, Sketch, Vec2;

  Color = require('../color').Color;

  Vec2 = require('../math/vector').Vec2;

  /*
  
    FIELDKIT SKETCH CLASS
  */


  Sketch = (function() {
    var TWO_PI, computeStyle, isFillEnabled, isStrokeEnabled;

    Sketch.prototype.width = -1;

    Sketch.prototype.height = -1;

    Sketch.prototype.canvasId = "sketch";

    Sketch.prototype.domObjectId = "container";

    Sketch.prototype.g = null;

    Sketch.prototype.mouseX = 0;

    Sketch.prototype.mouseY = 0;

    function Sketch(options) {
      var canvas, domObject,
        _this = this;

      domObject = document.getElementById(this.domObjectId);
      if (this.width === -1) {
        this.width = domObject.offsetWidth;
      }
      if (this.height === -1) {
        this.height = domObject.offsetHeight;
      }
      canvas = document.createElement("canvas");
      canvas.id = this.canvasId;
      canvas.width = this.width;
      canvas.height = this.height;
      domObject.appendChild(canvas);
      this.g = canvas.getContext("2d");
      this.setup();
      this.start();
      domObject.onmousemove = function(e) {
        _this.mouseX = e.x;
        return _this.mouseY = e.y;
      };
      domObject.onmousedown = function(e) {
        return _this.mouseDown();
      };
      domObject.onmouseup = function(e) {
        return _this.mouseUp();
      };
    }

    Sketch.prototype.isRunning = false;

    Sketch.prototype.isFinishedCallback = null;

    Sketch.prototype.start = function() {
      var render, requestId,
        _this = this;

      this.isRunning = true;
      requestId = null;
      render = function() {
        _this.draw();
        if (_this.isRunning) {
          return requestId = window.requestAnimationFrame(render);
        } else {
          window.cancelAnimationFrame(requestId);
          if (_this.isFinishedCallback != null) {
            return _this.isFinishedCallback();
          }
        }
      };
      return requestId = window.requestAnimationFrame(render);
    };

    Sketch.prototype.stop = function(callback) {
      this.isRunning = false;
      return this.isFinishedCallback = callback;
    };

    Sketch.prototype.toString = function() {
      return "Sketch";
    };

    /*
      Sketch API
    */


    Sketch.prototype.setup = function() {};

    Sketch.prototype.draw = function() {};

    Sketch.prototype.mouseDown = function() {};

    Sketch.prototype.mouseUp = function() {};

    /*
      2D Drawing API
    */


    isFillEnabled = true;

    isStrokeEnabled = false;

    TWO_PI = Math.PI * 2;

    computeStyle = function(args) {
      var arg, grey;

      switch (args.length) {
        case 1:
          arg = args[0];
          if (typeof arg === "string") {
            return arg;
          } else if (arg instanceof Color) {
            return arg.toCSS();
          } else {
            return "rgba(" + arg + ", " + arg + ", " + arg + ", 1)";
          }
          break;
        case 2:
          grey = args[0];
          return "rgba(" + grey + ", " + grey + ", " + grey + ", " + args[1] + ")";
        case 3:
          return "rgba(" + args[0] + ", " + args[1] + ", " + args[2] + ", 1)";
        case 4:
          return "rgba(" + args[0] + ", " + args[1] + ", " + args[2] + ", " + args[3] + ")";
        default:
          return "#FF0000";
      }
    };

    Sketch.prototype.color = function() {
      return computeStyle(arguments);
    };

    Sketch.prototype.background = function() {
      var style;

      this.g.clearRect(0, 0, this.width, this.height);
      style = this.g.fillStyle;
      this.g.fillStyle = computeStyle(arguments);
      this.g.fillRect(0, 0, this.width, this.height);
      return this.g.fillStyle = style;
    };

    Sketch.prototype.fill = function() {
      isFillEnabled = true;
      return this.g.fillStyle = computeStyle(arguments);
    };

    Sketch.prototype.stroke = function() {
      isStrokeEnabled = true;
      return this.g.strokeStyle = computeStyle(arguments);
    };

    Sketch.prototype.lineWidth = function(width) {
      return this.g.lineWidth = width;
    };

    Sketch.prototype.noFill = function() {
      return isFillEnabled = false;
    };

    Sketch.prototype.noStroke = function() {
      return isStrokeEnabled = false;
    };

    Sketch.prototype.rect = function(x, y, w, h) {
      if (isFillEnabled) {
        this.g.fillRect(x, y, w, h);
      }
      if (isStrokeEnabled) {
        return this.g.strokeRect(x, y, w, h);
      }
    };

    Sketch.prototype.circle = function(x, y, r) {
      this.g.beginPath();
      this.g.arc(x, y, r, 0, TWO_PI, false);
      if (isFillEnabled) {
        this.g.fill();
      }
      if (isStrokeEnabled) {
        this.g.stroke();
      }
      return this.g.closePath();
    };

    Sketch.prototype.line = function(x1, y1, x2, y2) {
      this.g.beginPath();
      if (x1 instanceof Vec2) {
        this.g.moveTo(x1.x, x1.y);
        this.g.lineTo(y1.x, y1.y);
      } else {
        this.g.moveTo(x1, y1);
        this.g.lineTo(x2, y2);
      }
      this.g.stroke();
      return this.g.closePath();
    };

    Sketch.prototype.polygon = function(points) {
      var p, _i, _len, _ref;

      this.g.beginPath();
      this.g.moveTo(points[0].x, points[0].y);
      _ref = points.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        this.g.lineTo(p.x, p.y);
      }
      if (isFillEnabled) {
        this.g.fill();
      }
      if (isStrokeEnabled) {
        this.g.stroke();
      }
      return this.g.closePath();
    };

    Sketch.prototype.createImage = function(width, height) {
      var imageData;

      imageData = this.g.createImageData(width, height);
      imageData.setPixel = function(x, y, r, g, b, a) {
        var index;

        if (a == null) {
          a = 255;
        }
        index = (x + y * this.width) * 4;
        this.data[index + 0] = r;
        this.data[index + 1] = g;
        this.data[index + 2] = b;
        return this.data[index + 3] = a;
      };
      return imageData;
    };

    Sketch.prototype.drawImage = function(imageData, x, y) {
      return this.g.putImageData(imageData, x, y);
    };

    return Sketch;

  })();

  module.exports = {
    Sketch: Sketch
  };

}).call(this);

},{"../color":3,"../math/vector":8}],18:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],17:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":18}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
/*

 Random based on Jon Watte's mersenne twister package.
 Adds several utility methods under a unified interface, that'll allow to use
 different number generators at some point.
*/


(function() {
  var Random, mersenne, util;

  mersenne = require('mersenne');

  util = require('../util');

  Random = (function() {
    function Random(initialSeed) {
      if (initialSeed == null) {
        initialSeed = 0;
      }
      this.seed(initialSeed);
    }

    Random.prototype.seed = function(value) {
      this.seedValue = value;
      return mersenne.seed(this.seedValue);
    };

    Random.prototype.toString = function() {
      return "Random(" + this.seedValue + ")";
    };

    Random.prototype.random = function() {
      var k;

      k = 1000000;
      return mersenne.rand(k) / k;
    };

    Random.prototype.randi = function(min, max) {
      return Math.floor(this.random() * (max - min) + min);
    };

    Random.prototype.randf = function(min, max) {
      return this.random() * (max - min) + min;
    };

    Random.prototype.flipCoin = function(chance) {
      if (chance == null) {
        chance = 0.5;
      }
      return this.random() < chance;
    };

    Random.prototype.shuffle = function(list) {
      return list.sort(function() {
        return 0.5 - this.random();
      });
    };

    Random.prototype.pick = function(list, count) {
      var i, indices, result, _i, _j, _ref;

      if (count == null) {
        count = 1;
      }
      switch (list.length) {
        case 0:
          return null;
        case 1:
          return list[0];
        default:
          if (count === 1) {
            return list[this.randi(0, list.length)];
          } else {
            indices = [];
            for (i = _i = 0, _ref = list.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
              indices.push(i);
            }
            util.shuffle(indices);
            result = [];
            for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {
              result.push(list[indices[i]]);
            }
            return result;
          }
      }
    };

    Random.prototype.pickAB = function(listA, listB, chance) {
      var list;

      list = this.next() < chance ? listA : listB;
      return this.pick(list);
    };

    return Random;

  })();

  module.exports.Random = Random;

}).call(this);

},{"../util":2,"mersenne":19}],19:[function(require,module,exports){
// this program is a JavaScript version of Mersenne Twister, with concealment and encapsulation in class,
// an almost straight conversion from the original program, mt19937ar.c,
// translated by y. okada on July 17, 2006.
// and modified a little at july 20, 2006, but there are not any substantial differences.
// in this program, procedure descriptions and comments of original source code were not removed.
// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.
// lines commented with /* and */ are original comments.
// lines commented with // are additional comments in this JavaScript version.
// before using this version, create at least one instance of MersenneTwister19937 class, and initialize the each state, given below in c comments, of all the instances.
/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_genrand(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

function MersenneTwister19937()
{
	/* constants should be scoped inside the class */
	var N, M, MATRIX_A, UPPER_MASK, LOWER_MASK;
	/* Period parameters */
	//c//#define N 624
	//c//#define M 397
	//c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
	//c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
	//c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */
	N = 624;
	M = 397;
	MATRIX_A = 0x9908b0df;   /* constant vector a */
	UPPER_MASK = 0x80000000; /* most significant w-r bits */
	LOWER_MASK = 0x7fffffff; /* least significant r bits */
	//c//static unsigned long mt[N]; /* the array for the state vector  */
	//c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */
	var mt = new Array(N);   /* the array for the state vector  */
	var mti = N+1;           /* mti==N+1 means mt[N] is not initialized */

	function unsigned32 (n1) // returns a 32-bits unsiged integer from an operand to which applied a bit operator.
	{
		return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1;
	}

	function subtraction32 (n1, n2) // emulates lowerflow of a c 32-bits unsiged integer variable, instead of the operator -. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) : n1 - n2;
	}

	function addition32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator +. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		return unsigned32((n1 + n2) & 0xffffffff)
	}

	function multiplication32 (n1, n2) // emulates overflow of a c 32-bits unsiged integer variable, instead of the operator *. these both arguments must be non-negative integers expressible using unsigned 32 bits.
	{
		var sum = 0;
		for (var i = 0; i < 32; ++i){
			if ((n1 >>> i) & 0x1){
				sum = addition32(sum, unsigned32(n2 << i));
			}
		}
		return sum;
	}

	/* initializes mt[N] with a seed */
	//c//void init_genrand(unsigned long s)
	this.init_genrand = function (s)
	{
		//c//mt[0]= s & 0xffffffff;
		mt[0]= unsigned32(s & 0xffffffff);
		for (mti=1; mti<N; mti++) {
			mt[mti] = 
			//c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
			addition32(multiplication32(1812433253, unsigned32(mt[mti-1] ^ (mt[mti-1] >>> 30))), mti);
			/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
			/* In the previous versions, MSBs of the seed affect   */
			/* only MSBs of the array mt[].                        */
			/* 2002/01/09 modified by Makoto Matsumoto             */
			//c//mt[mti] &= 0xffffffff;
			mt[mti] = unsigned32(mt[mti] & 0xffffffff);
			/* for >32 bit machines */
		}
	}

	/* initialize by an array with array-length */
	/* init_key is the array for initializing keys */
	/* key_length is its length */
	/* slight change for C++, 2004/2/26 */
	//c//void init_by_array(unsigned long init_key[], int key_length)
	this.init_by_array = function (init_key, key_length)
	{
		//c//int i, j, k;
		var i, j, k;
		//c//init_genrand(19650218);
		this.init_genrand(19650218);
		i=1; j=0;
		k = (N>key_length ? N : key_length);
		for (; k; k--) {
			//c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))
			//c//	+ init_key[j] + j; /* non linear */
			mt[i] = addition32(addition32(unsigned32(mt[i] ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1664525)), init_key[j]), j);
			mt[i] = 
			//c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
			unsigned32(mt[i] & 0xffffffff);
			i++; j++;
			if (i>=N) { mt[0] = mt[N-1]; i=1; }
			if (j>=key_length) j=0;
		}
		for (k=N-1; k; k--) {
			//c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))
			//c//- i; /* non linear */
			mt[i] = subtraction32(unsigned32((dbg=mt[i]) ^ multiplication32(unsigned32(mt[i-1] ^ (mt[i-1] >>> 30)), 1566083941)), i);
			//c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
			mt[i] = unsigned32(mt[i] & 0xffffffff);
			i++;
			if (i>=N) { mt[0] = mt[N-1]; i=1; }
		}
		mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
	}

    /* moved outside of genrand_int32() by jwatte 2010-11-17; generate less garbage */
    var mag01 = [0x0, MATRIX_A];

	/* generates a random number on [0,0xffffffff]-interval */
	//c//unsigned long genrand_int32(void)
	this.genrand_int32 = function ()
	{
		//c//unsigned long y;
		//c//static unsigned long mag01[2]={0x0UL, MATRIX_A};
		var y;
		/* mag01[x] = x * MATRIX_A  for x=0,1 */

		if (mti >= N) { /* generate N words at one time */
			//c//int kk;
			var kk;

			if (mti == N+1)   /* if init_genrand() has not been called, */
				//c//init_genrand(5489); /* a default initial seed is used */
				this.init_genrand(5489); /* a default initial seed is used */

			for (kk=0;kk<N-M;kk++) {
				//c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
				//c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
				y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
				mt[kk] = unsigned32(mt[kk+M] ^ (y >>> 1) ^ mag01[y & 0x1]);
			}
			for (;kk<N-1;kk++) {
				//c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
				//c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
				y = unsigned32((mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK));
				mt[kk] = unsigned32(mt[kk+(M-N)] ^ (y >>> 1) ^ mag01[y & 0x1]);
			}
			//c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
			//c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];
			y = unsigned32((mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK));
			mt[N-1] = unsigned32(mt[M-1] ^ (y >>> 1) ^ mag01[y & 0x1]);
			mti = 0;
		}

		y = mt[mti++];

		/* Tempering */
		//c//y ^= (y >> 11);
		//c//y ^= (y << 7) & 0x9d2c5680;
		//c//y ^= (y << 15) & 0xefc60000;
		//c//y ^= (y >> 18);
		y = unsigned32(y ^ (y >>> 11));
		y = unsigned32(y ^ ((y << 7) & 0x9d2c5680));
		y = unsigned32(y ^ ((y << 15) & 0xefc60000));
		y = unsigned32(y ^ (y >>> 18));

		return y;
	}

	/* generates a random number on [0,0x7fffffff]-interval */
	//c//long genrand_int31(void)
	this.genrand_int31 = function ()
	{
		//c//return (genrand_int32()>>1);
		return (this.genrand_int32()>>>1);
	}

	/* generates a random number on [0,1]-real-interval */
	//c//double genrand_real1(void)
	this.genrand_real1 = function ()
	{
		//c//return genrand_int32()*(1.0/4294967295.0);
		return this.genrand_int32()*(1.0/4294967295.0);
		/* divided by 2^32-1 */
	}

	/* generates a random number on [0,1)-real-interval */
	//c//double genrand_real2(void)
	this.genrand_real2 = function ()
	{
		//c//return genrand_int32()*(1.0/4294967296.0);
		return this.genrand_int32()*(1.0/4294967296.0);
		/* divided by 2^32 */
	}

	/* generates a random number on (0,1)-real-interval */
	//c//double genrand_real3(void)
	this.genrand_real3 = function ()
	{
		//c//return ((genrand_int32()) + 0.5)*(1.0/4294967296.0);
		return ((this.genrand_int32()) + 0.5)*(1.0/4294967296.0);
		/* divided by 2^32 */
	}

	/* generates a random number on [0,1) with 53-bit resolution*/
	//c//double genrand_res53(void)
	this.genrand_res53 = function ()
	{
		//c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;
		var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;
		return(a*67108864.0+b)*(1.0/9007199254740992.0);
	}
	/* These real versions are due to Isaku Wada, 2002/01/09 added */
}

//  Exports: Public API

//  Export the twister class
exports.MersenneTwister19937 = MersenneTwister19937;

//  Export a simplified function to generate random numbers
var gen = new MersenneTwister19937;
gen.init_genrand((new Date).getTime() % 1000000000);
exports.rand = function(N) {
    if (!N)
        {
        N = 32768;
        }
    return Math.floor(gen.genrand_real2() * N);
}
exports.seed = function(S) {
    if (typeof(S) != 'number')
        {
        throw new Error("seed(S) must take numeric argument; is " + typeof(S));
        }
    gen.init_genrand(S);
}
exports.seed_array = function(A) {
    if (typeof(A) != 'object')
        {
        throw new Error("seed_array(A) must take array of numbers; is " + typeof(A));
        }
    gen.init_by_array(A);
}



},{}]},{},[1])
;